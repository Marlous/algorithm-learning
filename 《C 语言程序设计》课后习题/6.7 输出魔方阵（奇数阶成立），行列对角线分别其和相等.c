/* 输出1~n平方的自然数构成的魔方阵

魔方阵的排列规律如下：
1. 将1放在第一行中间一列；
2. 从2开始直到n×n止各数依次按下列规则存放；
每一个数存放的行比前一个数的行数减1，列数加1（例如上面的三阶魔方阵，5在4的上一行后一列）；
3.如果上一个数的行数为1，则下一个数的行数为n（指最下一行）；例如1在第一行，则2应放在最下一行，列数同样加1；
4.当上一个数的列数为n时，下一个数的列数应为1，行数减去1。例如2在第3行最后一列，则3应放在第二行第一列；
5.如果按上面规则确定的位置上已有数，或上一个数是第一行第n列时，
则把下一个数放在上一个数的下面。例如按上面的规定，4应该放在第1行第2列，但该位置已经被占据，所以4就放在3的下面。 */
#include<stdio.h>
int main()
{
    int n,step,i,j;
    printf("Enter n: ");
    scanf("%d",&n);
    int num[n][n];
    putchar('\n');
    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            num[i][j]=0;
        }
    }
    //按规则转写成代码。
    i=0; //第一条件
    j=n/2;
    num[i][j]=1;
    for(step=2;step<=n*n;step++)
    {
        if(i!=0 && j!=(n-1) && (i!=0 && j!=(n-1))) //第二条件
        {
            if(num[i-1][j+1]!=0 || (i==0 && j==(n-1)))  //第五条件
            {
                num[i+1][j]=step;
                i=i+1;
            }
            else
            {
                num[i-1][j+1]=step;
                i=i-1; //更新行列值。
                j=j+1;
            }
            continue;

        }
        else if(i==0) //第三条件
        {
            if(num[n-1][j+1]!=0 || (i==0 && j==(n-1)))  //第五条件
            {
                num[i+1][j]=step;
                i=i+1;
            }
            else
            {
                num[n-1][j+1]=step;
                i=n-1;
                j=j+1;
            }
            continue;
        }
        else if(j==(n-1)) //第四条件
        {
            if(num[i-1][0]!=0 || (i==0 && j==(n-1)))  //第五条件
            {
                num[i+1][j]=step;
                i=i+1;
            }
            else
            {
                num[i-1][0]=step;
                i=i-1;
                j=0;
            }
            continue;
        }
    }

    for(i=0;i<n;i++)
    {
        for(j=0;j<n;j++)
        {
            printf("%3d",num[i][j]);
        }
        printf("\n");
    }
    return 0;
}
